{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { gql } from '@apollo/client';\nimport * as Apollo from '@apollo/client';\nconst defaultOptions = {};\n/** All built-in and custom scalars, mapped to their actual values */\n\nexport const RegularErrorFragmentDoc = gql`\n    fragment RegularError on FieldError {\n  field\n  message\n}\n    `;\nexport const RegularUserFragmentDoc = gql`\n    fragment RegularUser on User {\n  id\n  username\n}\n    `;\nexport const RegularUserResponseFragmentDoc = gql`\n    fragment RegularUserResponse on UserResponse {\n  errors {\n    ...RegularError\n  }\n  user {\n    ...RegularUser\n  }\n}\n    ${RegularErrorFragmentDoc}\n${RegularUserFragmentDoc}`;\nexport const CreateBaseRecipeDocument = gql`\n    mutation CreateBaseRecipe($input: RecipeInput!) {\n  createBaseRecipe(input: $input) {\n    id\n    name\n    description\n  }\n}\n    `;\n\n/**\n * __useCreateBaseRecipeMutation__\n *\n * To run a mutation, you first call `useCreateBaseRecipeMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useCreateBaseRecipeMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [createBaseRecipeMutation, { data, loading, error }] = useCreateBaseRecipeMutation({\n *   variables: {\n *      input: // value for 'input'\n *   },\n * });\n */\nexport function useCreateBaseRecipeMutation(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useMutation(CreateBaseRecipeDocument, options);\n}\nexport const CreateIngredientDocument = gql`\n    mutation CreateIngredient($input: IngredientInput!, $original: Boolean!, $recipeId: Int!) {\n  createIngredient(input: $input, original: $original, recipeId: $recipeId) {\n    id\n    name\n    quantity\n  }\n}\n    `;\n\n/**\n * __useCreateIngredientMutation__\n *\n * To run a mutation, you first call `useCreateIngredientMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useCreateIngredientMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [createIngredientMutation, { data, loading, error }] = useCreateIngredientMutation({\n *   variables: {\n *      input: // value for 'input'\n *      original: // value for 'original'\n *      recipeId: // value for 'recipeId'\n *   },\n * });\n */\nexport function useCreateIngredientMutation(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useMutation(CreateIngredientDocument, options);\n}\nexport const CreateInstructionDocument = gql`\n    mutation CreateInstruction($input: InstructionInput!, $original: Boolean!, $recipeId: Int!) {\n  createInstruction(input: $input, original: $original, recipeId: $recipeId) {\n    id\n    description\n    position\n  }\n}\n    `;\n\n/**\n * __useCreateInstructionMutation__\n *\n * To run a mutation, you first call `useCreateInstructionMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useCreateInstructionMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [createInstructionMutation, { data, loading, error }] = useCreateInstructionMutation({\n *   variables: {\n *      input: // value for 'input'\n *      original: // value for 'original'\n *      recipeId: // value for 'recipeId'\n *   },\n * });\n */\nexport function useCreateInstructionMutation(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useMutation(CreateInstructionDocument, options);\n}\nexport const DeleteBaseRecipeDocument = gql`\n    mutation DeleteBaseRecipe($id: Int!) {\n  deleteBaseRecipe(id: $id)\n}\n    `;\n\n/**\n * __useDeleteBaseRecipeMutation__\n *\n * To run a mutation, you first call `useDeleteBaseRecipeMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useDeleteBaseRecipeMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [deleteBaseRecipeMutation, { data, loading, error }] = useDeleteBaseRecipeMutation({\n *   variables: {\n *      id: // value for 'id'\n *   },\n * });\n */\nexport function useDeleteBaseRecipeMutation(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useMutation(DeleteBaseRecipeDocument, options);\n}\nexport const LoginDocument = gql`\n    mutation Login($usernameOrEmail: String!, $password: String!) {\n  login(usernameOrEmail: $usernameOrEmail, password: $password) {\n    ...RegularUserResponse\n  }\n}\n    ${RegularUserResponseFragmentDoc}`;\n\n/**\n * __useLoginMutation__\n *\n * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useLoginMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [loginMutation, { data, loading, error }] = useLoginMutation({\n *   variables: {\n *      usernameOrEmail: // value for 'usernameOrEmail'\n *      password: // value for 'password'\n *   },\n * });\n */\nexport function useLoginMutation(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useMutation(LoginDocument, options);\n}\nexport const LogoutDocument = gql`\n    mutation Logout {\n  logout\n}\n    `;\n\n/**\n * __useLogoutMutation__\n *\n * To run a mutation, you first call `useLogoutMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useLogoutMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [logoutMutation, { data, loading, error }] = useLogoutMutation({\n *   variables: {\n *   },\n * });\n */\nexport function useLogoutMutation(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useMutation(LogoutDocument, options);\n}\nexport const RegisterDocument = gql`\n    mutation Register($options: UsernamePasswordInput!) {\n  register(options: $options) {\n    ...RegularUserResponse\n  }\n}\n    ${RegularUserResponseFragmentDoc}`;\n\n/**\n * __useRegisterMutation__\n *\n * To run a mutation, you first call `useRegisterMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useRegisterMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [registerMutation, { data, loading, error }] = useRegisterMutation({\n *   variables: {\n *      options: // value for 'options'\n *   },\n * });\n */\nexport function useRegisterMutation(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useMutation(RegisterDocument, options);\n}\nexport const UpdateBaseRecipeDocument = gql`\n    mutation UpdateBaseRecipe($id: Int!, $name: String!, $description: String!) {\n  updateBaseRecipe(id: $id, name: $name, description: $description) {\n    id\n    name\n    description\n  }\n}\n    `;\n\n/**\n * __useUpdateBaseRecipeMutation__\n *\n * To run a mutation, you first call `useUpdateBaseRecipeMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useUpdateBaseRecipeMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [updateBaseRecipeMutation, { data, loading, error }] = useUpdateBaseRecipeMutation({\n *   variables: {\n *      id: // value for 'id'\n *      name: // value for 'name'\n *      description: // value for 'description'\n *   },\n * });\n */\nexport function useUpdateBaseRecipeMutation(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useMutation(UpdateBaseRecipeDocument, options);\n}\nexport const UpdateIngredientDocument = gql`\n    mutation UpdateIngredient($id: Int!, $input: IngredientInput!) {\n  updateIngredient(id: $id, input: $input) {\n    id\n    name\n    quantity\n  }\n}\n    `;\n\n/**\n * __useUpdateIngredientMutation__\n *\n * To run a mutation, you first call `useUpdateIngredientMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useUpdateIngredientMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [updateIngredientMutation, { data, loading, error }] = useUpdateIngredientMutation({\n *   variables: {\n *      id: // value for 'id'\n *      input: // value for 'input'\n *   },\n * });\n */\nexport function useUpdateIngredientMutation(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useMutation(UpdateIngredientDocument, options);\n}\nexport const UpdateInstructionDocument = gql`\n    mutation UpdateInstruction($id: Int!, $input: InstructionInput!) {\n  updateInstruction(id: $id, input: $input) {\n    id\n    position\n    description\n  }\n}\n    `;\n\n/**\n * __useUpdateInstructionMutation__\n *\n * To run a mutation, you first call `useUpdateInstructionMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useUpdateInstructionMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [updateInstructionMutation, { data, loading, error }] = useUpdateInstructionMutation({\n *   variables: {\n *      id: // value for 'id'\n *      input: // value for 'input'\n *   },\n * });\n */\nexport function useUpdateInstructionMutation(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useMutation(UpdateInstructionDocument, options);\n}\nexport const BaseRecipeDocument = gql`\n    query BaseRecipe($id: Int!) {\n  baseRecipe(id: $id) {\n    id\n    name\n    description\n  }\n}\n    `;\n/**\n * __useBaseRecipeQuery__\n *\n * To run a query within a React component, call `useBaseRecipeQuery` and pass it any options that fit your needs.\n * When your component renders, `useBaseRecipeQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useBaseRecipeQuery({\n *   variables: {\n *      id: // value for 'id'\n *   },\n * });\n */\n\nexport function useBaseRecipeQuery(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useQuery(BaseRecipeDocument, options);\n}\nexport function useBaseRecipeLazyQuery(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useLazyQuery(BaseRecipeDocument, options);\n}\nexport const MeDocument = gql`\n    query Me {\n  me {\n    ...RegularUser\n  }\n}\n    ${RegularUserFragmentDoc}`;\n/**\n * __useMeQuery__\n *\n * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.\n * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useMeQuery({\n *   variables: {\n *   },\n * });\n */\n\nexport function useMeQuery(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useQuery(MeDocument, options);\n}\nexport function useMeLazyQuery(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useLazyQuery(MeDocument, options);\n}\nexport const RecipeIngredientsDocument = gql`\n    query RecipeIngredients($id: Int!, $original: Boolean!) {\n  recipeIngredients(recipeId: $id, original: $original) {\n    id\n    name\n    quantity\n  }\n}\n    `;\n/**\n * __useRecipeIngredientsQuery__\n *\n * To run a query within a React component, call `useRecipeIngredientsQuery` and pass it any options that fit your needs.\n * When your component renders, `useRecipeIngredientsQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useRecipeIngredientsQuery({\n *   variables: {\n *      id: // value for 'id'\n *      original: // value for 'original'\n *   },\n * });\n */\n\nexport function useRecipeIngredientsQuery(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useQuery(RecipeIngredientsDocument, options);\n}\nexport function useRecipeIngredientsLazyQuery(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useLazyQuery(RecipeIngredientsDocument, options);\n}\nexport const RecipeInstructionsDocument = gql`\n    query RecipeInstructions($id: Int!, $original: Boolean!) {\n  recipeInstructions(recipeId: $id, original: $original) {\n    id\n    position\n    description\n  }\n}\n    `;\n/**\n * __useRecipeInstructionsQuery__\n *\n * To run a query within a React component, call `useRecipeInstructionsQuery` and pass it any options that fit your needs.\n * When your component renders, `useRecipeInstructionsQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useRecipeInstructionsQuery({\n *   variables: {\n *      id: // value for 'id'\n *      original: // value for 'original'\n *   },\n * });\n */\n\nexport function useRecipeInstructionsQuery(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useQuery(RecipeInstructionsDocument, options);\n}\nexport function useRecipeInstructionsLazyQuery(baseOptions) {\n  const options = _objectSpread(_objectSpread({}, defaultOptions), baseOptions);\n\n  return Apollo.useLazyQuery(RecipeInstructionsDocument, options);\n}","map":{"version":3,"sources":["/Users/w/Development/projects/chefnotes/chefnotes-app/src/generated/graphql.tsx"],"names":["gql","Apollo","defaultOptions","RegularErrorFragmentDoc","RegularUserFragmentDoc","RegularUserResponseFragmentDoc","CreateBaseRecipeDocument","useCreateBaseRecipeMutation","baseOptions","options","useMutation","CreateIngredientDocument","useCreateIngredientMutation","CreateInstructionDocument","useCreateInstructionMutation","DeleteBaseRecipeDocument","useDeleteBaseRecipeMutation","LoginDocument","useLoginMutation","LogoutDocument","useLogoutMutation","RegisterDocument","useRegisterMutation","UpdateBaseRecipeDocument","useUpdateBaseRecipeMutation","UpdateIngredientDocument","useUpdateIngredientMutation","UpdateInstructionDocument","useUpdateInstructionMutation","BaseRecipeDocument","useBaseRecipeQuery","useQuery","useBaseRecipeLazyQuery","useLazyQuery","MeDocument","useMeQuery","useMeLazyQuery","RecipeIngredientsDocument","useRecipeIngredientsQuery","useRecipeIngredientsLazyQuery","RecipeInstructionsDocument","useRecipeInstructionsQuery","useRecipeInstructionsLazyQuery"],"mappings":";;;;;;AAAA,SAASA,GAAT,QAAoB,gBAApB;AACA,OAAO,KAAKC,MAAZ,MAAwB,gBAAxB;AAKA,MAAMC,cAAc,GAAI,EAAxB;AACA;;AAyYA,OAAO,MAAMC,uBAAuB,GAAGH,GAAI;AAC3C;AACA;AACA;AACA;AACA,KALO;AAMP,OAAO,MAAMI,sBAAsB,GAAGJ,GAAI;AAC1C;AACA;AACA;AACA;AACA,KALO;AAMP,OAAO,MAAMK,8BAA8B,GAAGL,GAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,uBAAwB;AAC9B,EAAEC,sBAAuB,EAVlB;AAWP,OAAO,MAAME,wBAAwB,GAAGN,GAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KARO;;AAWP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASO,2BAAT,CAAqCC,WAArC,EAA4I;AAC3I,QAAMC,OAAO,mCAAOP,cAAP,GAA0BM,WAA1B,CAAb;;AACA,SAAOP,MAAM,CAACS,WAAP,CAAgFJ,wBAAhF,EAA0GG,OAA1G,CAAP;AACD;AAIP,OAAO,MAAME,wBAAwB,GAAGX,GAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KARO;;AAWP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASY,2BAAT,CAAqCJ,WAArC,EAA4I;AAC3I,QAAMC,OAAO,mCAAOP,cAAP,GAA0BM,WAA1B,CAAb;;AACA,SAAOP,MAAM,CAACS,WAAP,CAAgFC,wBAAhF,EAA0GF,OAA1G,CAAP;AACD;AAIP,OAAO,MAAMI,yBAAyB,GAAGb,GAAI;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KARO;;AAWP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASc,4BAAT,CAA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","sourcesContent":["import { gql } from '@apollo/client';\nimport * as Apollo from '@apollo/client';\nexport type Maybe<T> = T | null;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nconst defaultOptions =  {}\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n};\n\nexport type Query = {\n  __typename?: 'Query';\n  me?: Maybe<User>;\n  recipesAll: Array<BaseRecipe>;\n  baseRecipes: PaginatedRecipes;\n  userBaseRecipes: Array<BaseRecipe>;\n  baseRecipe?: Maybe<BaseRecipe>;\n  recipeIngredients: Array<Ingredient>;\n  recipeInstructions: Array<Instruction>;\n};\n\n\nexport type QueryBaseRecipesArgs = {\n  cursor?: Maybe<Scalars['String']>;\n  limit: Scalars['Int'];\n};\n\n\nexport type QueryBaseRecipeArgs = {\n  id: Scalars['Int'];\n};\n\n\nexport type QueryRecipeIngredientsArgs = {\n  original: Scalars['Boolean'];\n  recipeId: Scalars['Int'];\n};\n\n\nexport type QueryRecipeInstructionsArgs = {\n  original: Scalars['Boolean'];\n  recipeId: Scalars['Int'];\n};\n\nexport type User = {\n  __typename?: 'User';\n  id: Scalars['Float'];\n  username: Scalars['String'];\n};\n\nexport type BaseRecipe = {\n  __typename?: 'BaseRecipe';\n  id: Scalars['Float'];\n  name: Scalars['String'];\n  description: Scalars['String'];\n  creatorId: Scalars['Float'];\n};\n\nexport type PaginatedRecipes = {\n  __typename?: 'PaginatedRecipes';\n  recipes: Array<BaseRecipe>;\n  hasMore: Scalars['Boolean'];\n};\n\nexport type Ingredient = {\n  __typename?: 'Ingredient';\n  id: Scalars['Float'];\n  name: Scalars['String'];\n  quantity: Scalars['String'];\n};\n\nexport type Instruction = {\n  __typename?: 'Instruction';\n  id: Scalars['Float'];\n  description: Scalars['String'];\n  position: Scalars['Float'];\n};\n\nexport type Mutation = {\n  __typename?: 'Mutation';\n  register: UserResponse;\n  login: UserResponse;\n  logout: Scalars['Boolean'];\n  createBaseRecipe: BaseRecipe;\n  updateBaseRecipe: BaseRecipe;\n  deleteBaseRecipe: Scalars['Boolean'];\n  createIngredient: Ingredient;\n  updateIngredient?: Maybe<Ingredient>;\n  deleteIngredient: Scalars['Boolean'];\n  createInstruction: Instruction;\n  updateInstruction?: Maybe<Instruction>;\n  deleteInstruction: Scalars['Boolean'];\n};\n\n\nexport type MutationRegisterArgs = {\n  options: UsernamePasswordInput;\n};\n\n\nexport type MutationLoginArgs = {\n  password: Scalars['String'];\n  usernameOrEmail: Scalars['String'];\n};\n\n\nexport type MutationCreateBaseRecipeArgs = {\n  input: RecipeInput;\n};\n\n\nexport type MutationUpdateBaseRecipeArgs = {\n  description: Scalars['String'];\n  name: Scalars['String'];\n  id: Scalars['Int'];\n};\n\n\nexport type MutationDeleteBaseRecipeArgs = {\n  id: Scalars['Int'];\n};\n\n\nexport type MutationCreateIngredientArgs = {\n  recipeId: Scalars['Int'];\n  original: Scalars['Boolean'];\n  input: IngredientInput;\n};\n\n\nexport type MutationUpdateIngredientArgs = {\n  input: IngredientInput;\n  id: Scalars['Int'];\n};\n\n\nexport type MutationDeleteIngredientArgs = {\n  id: Scalars['Int'];\n};\n\n\nexport type MutationCreateInstructionArgs = {\n  recipeId: Scalars['Int'];\n  original: Scalars['Boolean'];\n  input: InstructionInput;\n};\n\n\nexport type MutationUpdateInstructionArgs = {\n  input: InstructionInput;\n  id: Scalars['Int'];\n};\n\n\nexport type MutationDeleteInstructionArgs = {\n  id: Scalars['Int'];\n};\n\nexport type UserResponse = {\n  __typename?: 'UserResponse';\n  errors?: Maybe<Array<FieldError>>;\n  user?: Maybe<User>;\n};\n\nexport type FieldError = {\n  __typename?: 'FieldError';\n  field: Scalars['String'];\n  message: Scalars['String'];\n};\n\nexport type UsernamePasswordInput = {\n  username: Scalars['String'];\n  password: Scalars['String'];\n};\n\nexport type RecipeInput = {\n  name: Scalars['String'];\n  description: Scalars['String'];\n};\n\nexport type IngredientInput = {\n  name: Scalars['String'];\n  quantity: Scalars['String'];\n};\n\nexport type InstructionInput = {\n  description: Scalars['String'];\n  position: Scalars['Float'];\n};\n\nexport type RegularErrorFragment = (\n  { __typename?: 'FieldError' }\n  & Pick<FieldError, 'field' | 'message'>\n);\n\nexport type RegularUserFragment = (\n  { __typename?: 'User' }\n  & Pick<User, 'id' | 'username'>\n);\n\nexport type RegularUserResponseFragment = (\n  { __typename?: 'UserResponse' }\n  & { errors?: Maybe<Array<(\n    { __typename?: 'FieldError' }\n    & RegularErrorFragment\n  )>>, user?: Maybe<(\n    { __typename?: 'User' }\n    & RegularUserFragment\n  )> }\n);\n\nexport type CreateBaseRecipeMutationVariables = Exact<{\n  input: RecipeInput;\n}>;\n\n\nexport type CreateBaseRecipeMutation = (\n  { __typename?: 'Mutation' }\n  & { createBaseRecipe: (\n    { __typename?: 'BaseRecipe' }\n    & Pick<BaseRecipe, 'id' | 'name' | 'description'>\n  ) }\n);\n\nexport type CreateIngredientMutationVariables = Exact<{\n  input: IngredientInput;\n  original: Scalars['Boolean'];\n  recipeId: Scalars['Int'];\n}>;\n\n\nexport type CreateIngredientMutation = (\n  { __typename?: 'Mutation' }\n  & { createIngredient: (\n    { __typename?: 'Ingredient' }\n    & Pick<Ingredient, 'id' | 'name' | 'quantity'>\n  ) }\n);\n\nexport type CreateInstructionMutationVariables = Exact<{\n  input: InstructionInput;\n  original: Scalars['Boolean'];\n  recipeId: Scalars['Int'];\n}>;\n\n\nexport type CreateInstructionMutation = (\n  { __typename?: 'Mutation' }\n  & { createInstruction: (\n    { __typename?: 'Instruction' }\n    & Pick<Instruction, 'id' | 'description' | 'position'>\n  ) }\n);\n\nexport type DeleteBaseRecipeMutationVariables = Exact<{\n  id: Scalars['Int'];\n}>;\n\n\nexport type DeleteBaseRecipeMutation = (\n  { __typename?: 'Mutation' }\n  & Pick<Mutation, 'deleteBaseRecipe'>\n);\n\nexport type LoginMutationVariables = Exact<{\n  usernameOrEmail: Scalars['String'];\n  password: Scalars['String'];\n}>;\n\n\nexport type LoginMutation = (\n  { __typename?: 'Mutation' }\n  & { login: (\n    { __typename?: 'UserResponse' }\n    & RegularUserResponseFragment\n  ) }\n);\n\nexport type LogoutMutationVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type LogoutMutation = (\n  { __typename?: 'Mutation' }\n  & Pick<Mutation, 'logout'>\n);\n\nexport type RegisterMutationVariables = Exact<{\n  options: UsernamePasswordInput;\n}>;\n\n\nexport type RegisterMutation = (\n  { __typename?: 'Mutation' }\n  & { register: (\n    { __typename?: 'UserResponse' }\n    & RegularUserResponseFragment\n  ) }\n);\n\nexport type UpdateBaseRecipeMutationVariables = Exact<{\n  id: Scalars['Int'];\n  name: Scalars['String'];\n  description: Scalars['String'];\n}>;\n\n\nexport type UpdateBaseRecipeMutation = (\n  { __typename?: 'Mutation' }\n  & { updateBaseRecipe: (\n    { __typename?: 'BaseRecipe' }\n    & Pick<BaseRecipe, 'id' | 'name' | 'description'>\n  ) }\n);\n\nexport type UpdateIngredientMutationVariables = Exact<{\n  id: Scalars['Int'];\n  input: IngredientInput;\n}>;\n\n\nexport type UpdateIngredientMutation = (\n  { __typename?: 'Mutation' }\n  & { updateIngredient?: Maybe<(\n    { __typename?: 'Ingredient' }\n    & Pick<Ingredient, 'id' | 'name' | 'quantity'>\n  )> }\n);\n\nexport type UpdateInstructionMutationVariables = Exact<{\n  id: Scalars['Int'];\n  input: InstructionInput;\n}>;\n\n\nexport type UpdateInstructionMutation = (\n  { __typename?: 'Mutation' }\n  & { updateInstruction?: Maybe<(\n    { __typename?: 'Instruction' }\n    & Pick<Instruction, 'id' | 'position' | 'description'>\n  )> }\n);\n\nexport type BaseRecipeQueryVariables = Exact<{\n  id: Scalars['Int'];\n}>;\n\n\nexport type BaseRecipeQuery = (\n  { __typename?: 'Query' }\n  & { baseRecipe?: Maybe<(\n    { __typename?: 'BaseRecipe' }\n    & Pick<BaseRecipe, 'id' | 'name' | 'description'>\n  )> }\n);\n\nexport type MeQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type MeQuery = (\n  { __typename?: 'Query' }\n  & { me?: Maybe<(\n    { __typename?: 'User' }\n    & RegularUserFragment\n  )> }\n);\n\nexport type RecipeIngredientsQueryVariables = Exact<{\n  id: Scalars['Int'];\n  original: Scalars['Boolean'];\n}>;\n\n\nexport type RecipeIngredientsQuery = (\n  { __typename?: 'Query' }\n  & { recipeIngredients: Array<(\n    { __typename?: 'Ingredient' }\n    & Pick<Ingredient, 'id' | 'name' | 'quantity'>\n  )> }\n);\n\nexport type RecipeInstructionsQueryVariables = Exact<{\n  id: Scalars['Int'];\n  original: Scalars['Boolean'];\n}>;\n\n\nexport type RecipeInstructionsQuery = (\n  { __typename?: 'Query' }\n  & { recipeInstructions: Array<(\n    { __typename?: 'Instruction' }\n    & Pick<Instruction, 'id' | 'position' | 'description'>\n  )> }\n);\n\nexport const RegularErrorFragmentDoc = gql`\n    fragment RegularError on FieldError {\n  field\n  message\n}\n    `;\nexport const RegularUserFragmentDoc = gql`\n    fragment RegularUser on User {\n  id\n  username\n}\n    `;\nexport const RegularUserResponseFragmentDoc = gql`\n    fragment RegularUserResponse on UserResponse {\n  errors {\n    ...RegularError\n  }\n  user {\n    ...RegularUser\n  }\n}\n    ${RegularErrorFragmentDoc}\n${RegularUserFragmentDoc}`;\nexport const CreateBaseRecipeDocument = gql`\n    mutation CreateBaseRecipe($input: RecipeInput!) {\n  createBaseRecipe(input: $input) {\n    id\n    name\n    description\n  }\n}\n    `;\nexport type CreateBaseRecipeMutationFn = Apollo.MutationFunction<CreateBaseRecipeMutation, CreateBaseRecipeMutationVariables>;\n\n/**\n * __useCreateBaseRecipeMutation__\n *\n * To run a mutation, you first call `useCreateBaseRecipeMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useCreateBaseRecipeMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [createBaseRecipeMutation, { data, loading, error }] = useCreateBaseRecipeMutation({\n *   variables: {\n *      input: // value for 'input'\n *   },\n * });\n */\nexport function useCreateBaseRecipeMutation(baseOptions?: Apollo.MutationHookOptions<CreateBaseRecipeMutation, CreateBaseRecipeMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<CreateBaseRecipeMutation, CreateBaseRecipeMutationVariables>(CreateBaseRecipeDocument, options);\n      }\nexport type CreateBaseRecipeMutationHookResult = ReturnType<typeof useCreateBaseRecipeMutation>;\nexport type CreateBaseRecipeMutationResult = Apollo.MutationResult<CreateBaseRecipeMutation>;\nexport type CreateBaseRecipeMutationOptions = Apollo.BaseMutationOptions<CreateBaseRecipeMutation, CreateBaseRecipeMutationVariables>;\nexport const CreateIngredientDocument = gql`\n    mutation CreateIngredient($input: IngredientInput!, $original: Boolean!, $recipeId: Int!) {\n  createIngredient(input: $input, original: $original, recipeId: $recipeId) {\n    id\n    name\n    quantity\n  }\n}\n    `;\nexport type CreateIngredientMutationFn = Apollo.MutationFunction<CreateIngredientMutation, CreateIngredientMutationVariables>;\n\n/**\n * __useCreateIngredientMutation__\n *\n * To run a mutation, you first call `useCreateIngredientMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useCreateIngredientMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [createIngredientMutation, { data, loading, error }] = useCreateIngredientMutation({\n *   variables: {\n *      input: // value for 'input'\n *      original: // value for 'original'\n *      recipeId: // value for 'recipeId'\n *   },\n * });\n */\nexport function useCreateIngredientMutation(baseOptions?: Apollo.MutationHookOptions<CreateIngredientMutation, CreateIngredientMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<CreateIngredientMutation, CreateIngredientMutationVariables>(CreateIngredientDocument, options);\n      }\nexport type CreateIngredientMutationHookResult = ReturnType<typeof useCreateIngredientMutation>;\nexport type CreateIngredientMutationResult = Apollo.MutationResult<CreateIngredientMutation>;\nexport type CreateIngredientMutationOptions = Apollo.BaseMutationOptions<CreateIngredientMutation, CreateIngredientMutationVariables>;\nexport const CreateInstructionDocument = gql`\n    mutation CreateInstruction($input: InstructionInput!, $original: Boolean!, $recipeId: Int!) {\n  createInstruction(input: $input, original: $original, recipeId: $recipeId) {\n    id\n    description\n    position\n  }\n}\n    `;\nexport type CreateInstructionMutationFn = Apollo.MutationFunction<CreateInstructionMutation, CreateInstructionMutationVariables>;\n\n/**\n * __useCreateInstructionMutation__\n *\n * To run a mutation, you first call `useCreateInstructionMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useCreateInstructionMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [createInstructionMutation, { data, loading, error }] = useCreateInstructionMutation({\n *   variables: {\n *      input: // value for 'input'\n *      original: // value for 'original'\n *      recipeId: // value for 'recipeId'\n *   },\n * });\n */\nexport function useCreateInstructionMutation(baseOptions?: Apollo.MutationHookOptions<CreateInstructionMutation, CreateInstructionMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<CreateInstructionMutation, CreateInstructionMutationVariables>(CreateInstructionDocument, options);\n      }\nexport type CreateInstructionMutationHookResult = ReturnType<typeof useCreateInstructionMutation>;\nexport type CreateInstructionMutationResult = Apollo.MutationResult<CreateInstructionMutation>;\nexport type CreateInstructionMutationOptions = Apollo.BaseMutationOptions<CreateInstructionMutation, CreateInstructionMutationVariables>;\nexport const DeleteBaseRecipeDocument = gql`\n    mutation DeleteBaseRecipe($id: Int!) {\n  deleteBaseRecipe(id: $id)\n}\n    `;\nexport type DeleteBaseRecipeMutationFn = Apollo.MutationFunction<DeleteBaseRecipeMutation, DeleteBaseRecipeMutationVariables>;\n\n/**\n * __useDeleteBaseRecipeMutation__\n *\n * To run a mutation, you first call `useDeleteBaseRecipeMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useDeleteBaseRecipeMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [deleteBaseRecipeMutation, { data, loading, error }] = useDeleteBaseRecipeMutation({\n *   variables: {\n *      id: // value for 'id'\n *   },\n * });\n */\nexport function useDeleteBaseRecipeMutation(baseOptions?: Apollo.MutationHookOptions<DeleteBaseRecipeMutation, DeleteBaseRecipeMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<DeleteBaseRecipeMutation, DeleteBaseRecipeMutationVariables>(DeleteBaseRecipeDocument, options);\n      }\nexport type DeleteBaseRecipeMutationHookResult = ReturnType<typeof useDeleteBaseRecipeMutation>;\nexport type DeleteBaseRecipeMutationResult = Apollo.MutationResult<DeleteBaseRecipeMutation>;\nexport type DeleteBaseRecipeMutationOptions = Apollo.BaseMutationOptions<DeleteBaseRecipeMutation, DeleteBaseRecipeMutationVariables>;\nexport const LoginDocument = gql`\n    mutation Login($usernameOrEmail: String!, $password: String!) {\n  login(usernameOrEmail: $usernameOrEmail, password: $password) {\n    ...RegularUserResponse\n  }\n}\n    ${RegularUserResponseFragmentDoc}`;\nexport type LoginMutationFn = Apollo.MutationFunction<LoginMutation, LoginMutationVariables>;\n\n/**\n * __useLoginMutation__\n *\n * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useLoginMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [loginMutation, { data, loading, error }] = useLoginMutation({\n *   variables: {\n *      usernameOrEmail: // value for 'usernameOrEmail'\n *      password: // value for 'password'\n *   },\n * });\n */\nexport function useLoginMutation(baseOptions?: Apollo.MutationHookOptions<LoginMutation, LoginMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<LoginMutation, LoginMutationVariables>(LoginDocument, options);\n      }\nexport type LoginMutationHookResult = ReturnType<typeof useLoginMutation>;\nexport type LoginMutationResult = Apollo.MutationResult<LoginMutation>;\nexport type LoginMutationOptions = Apollo.BaseMutationOptions<LoginMutation, LoginMutationVariables>;\nexport const LogoutDocument = gql`\n    mutation Logout {\n  logout\n}\n    `;\nexport type LogoutMutationFn = Apollo.MutationFunction<LogoutMutation, LogoutMutationVariables>;\n\n/**\n * __useLogoutMutation__\n *\n * To run a mutation, you first call `useLogoutMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useLogoutMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [logoutMutation, { data, loading, error }] = useLogoutMutation({\n *   variables: {\n *   },\n * });\n */\nexport function useLogoutMutation(baseOptions?: Apollo.MutationHookOptions<LogoutMutation, LogoutMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<LogoutMutation, LogoutMutationVariables>(LogoutDocument, options);\n      }\nexport type LogoutMutationHookResult = ReturnType<typeof useLogoutMutation>;\nexport type LogoutMutationResult = Apollo.MutationResult<LogoutMutation>;\nexport type LogoutMutationOptions = Apollo.BaseMutationOptions<LogoutMutation, LogoutMutationVariables>;\nexport const RegisterDocument = gql`\n    mutation Register($options: UsernamePasswordInput!) {\n  register(options: $options) {\n    ...RegularUserResponse\n  }\n}\n    ${RegularUserResponseFragmentDoc}`;\nexport type RegisterMutationFn = Apollo.MutationFunction<RegisterMutation, RegisterMutationVariables>;\n\n/**\n * __useRegisterMutation__\n *\n * To run a mutation, you first call `useRegisterMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useRegisterMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [registerMutation, { data, loading, error }] = useRegisterMutation({\n *   variables: {\n *      options: // value for 'options'\n *   },\n * });\n */\nexport function useRegisterMutation(baseOptions?: Apollo.MutationHookOptions<RegisterMutation, RegisterMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<RegisterMutation, RegisterMutationVariables>(RegisterDocument, options);\n      }\nexport type RegisterMutationHookResult = ReturnType<typeof useRegisterMutation>;\nexport type RegisterMutationResult = Apollo.MutationResult<RegisterMutation>;\nexport type RegisterMutationOptions = Apollo.BaseMutationOptions<RegisterMutation, RegisterMutationVariables>;\nexport const UpdateBaseRecipeDocument = gql`\n    mutation UpdateBaseRecipe($id: Int!, $name: String!, $description: String!) {\n  updateBaseRecipe(id: $id, name: $name, description: $description) {\n    id\n    name\n    description\n  }\n}\n    `;\nexport type UpdateBaseRecipeMutationFn = Apollo.MutationFunction<UpdateBaseRecipeMutation, UpdateBaseRecipeMutationVariables>;\n\n/**\n * __useUpdateBaseRecipeMutation__\n *\n * To run a mutation, you first call `useUpdateBaseRecipeMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useUpdateBaseRecipeMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [updateBaseRecipeMutation, { data, loading, error }] = useUpdateBaseRecipeMutation({\n *   variables: {\n *      id: // value for 'id'\n *      name: // value for 'name'\n *      description: // value for 'description'\n *   },\n * });\n */\nexport function useUpdateBaseRecipeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateBaseRecipeMutation, UpdateBaseRecipeMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<UpdateBaseRecipeMutation, UpdateBaseRecipeMutationVariables>(UpdateBaseRecipeDocument, options);\n      }\nexport type UpdateBaseRecipeMutationHookResult = ReturnType<typeof useUpdateBaseRecipeMutation>;\nexport type UpdateBaseRecipeMutationResult = Apollo.MutationResult<UpdateBaseRecipeMutation>;\nexport type UpdateBaseRecipeMutationOptions = Apollo.BaseMutationOptions<UpdateBaseRecipeMutation, UpdateBaseRecipeMutationVariables>;\nexport const UpdateIngredientDocument = gql`\n    mutation UpdateIngredient($id: Int!, $input: IngredientInput!) {\n  updateIngredient(id: $id, input: $input) {\n    id\n    name\n    quantity\n  }\n}\n    `;\nexport type UpdateIngredientMutationFn = Apollo.MutationFunction<UpdateIngredientMutation, UpdateIngredientMutationVariables>;\n\n/**\n * __useUpdateIngredientMutation__\n *\n * To run a mutation, you first call `useUpdateIngredientMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useUpdateIngredientMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [updateIngredientMutation, { data, loading, error }] = useUpdateIngredientMutation({\n *   variables: {\n *      id: // value for 'id'\n *      input: // value for 'input'\n *   },\n * });\n */\nexport function useUpdateIngredientMutation(baseOptions?: Apollo.MutationHookOptions<UpdateIngredientMutation, UpdateIngredientMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<UpdateIngredientMutation, UpdateIngredientMutationVariables>(UpdateIngredientDocument, options);\n      }\nexport type UpdateIngredientMutationHookResult = ReturnType<typeof useUpdateIngredientMutation>;\nexport type UpdateIngredientMutationResult = Apollo.MutationResult<UpdateIngredientMutation>;\nexport type UpdateIngredientMutationOptions = Apollo.BaseMutationOptions<UpdateIngredientMutation, UpdateIngredientMutationVariables>;\nexport const UpdateInstructionDocument = gql`\n    mutation UpdateInstruction($id: Int!, $input: InstructionInput!) {\n  updateInstruction(id: $id, input: $input) {\n    id\n    position\n    description\n  }\n}\n    `;\nexport type UpdateInstructionMutationFn = Apollo.MutationFunction<UpdateInstructionMutation, UpdateInstructionMutationVariables>;\n\n/**\n * __useUpdateInstructionMutation__\n *\n * To run a mutation, you first call `useUpdateInstructionMutation` within a React component and pass it any options that fit your needs.\n * When your component renders, `useUpdateInstructionMutation` returns a tuple that includes:\n * - A mutate function that you can call at any time to execute the mutation\n * - An object with fields that represent the current status of the mutation's execution\n *\n * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;\n *\n * @example\n * const [updateInstructionMutation, { data, loading, error }] = useUpdateInstructionMutation({\n *   variables: {\n *      id: // value for 'id'\n *      input: // value for 'input'\n *   },\n * });\n */\nexport function useUpdateInstructionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInstructionMutation, UpdateInstructionMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<UpdateInstructionMutation, UpdateInstructionMutationVariables>(UpdateInstructionDocument, options);\n      }\nexport type UpdateInstructionMutationHookResult = ReturnType<typeof useUpdateInstructionMutation>;\nexport type UpdateInstructionMutationResult = Apollo.MutationResult<UpdateInstructionMutation>;\nexport type UpdateInstructionMutationOptions = Apollo.BaseMutationOptions<UpdateInstructionMutation, UpdateInstructionMutationVariables>;\nexport const BaseRecipeDocument = gql`\n    query BaseRecipe($id: Int!) {\n  baseRecipe(id: $id) {\n    id\n    name\n    description\n  }\n}\n    `;\n\n/**\n * __useBaseRecipeQuery__\n *\n * To run a query within a React component, call `useBaseRecipeQuery` and pass it any options that fit your needs.\n * When your component renders, `useBaseRecipeQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useBaseRecipeQuery({\n *   variables: {\n *      id: // value for 'id'\n *   },\n * });\n */\nexport function useBaseRecipeQuery(baseOptions: Apollo.QueryHookOptions<BaseRecipeQuery, BaseRecipeQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<BaseRecipeQuery, BaseRecipeQueryVariables>(BaseRecipeDocument, options);\n      }\nexport function useBaseRecipeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BaseRecipeQuery, BaseRecipeQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<BaseRecipeQuery, BaseRecipeQueryVariables>(BaseRecipeDocument, options);\n        }\nexport type BaseRecipeQueryHookResult = ReturnType<typeof useBaseRecipeQuery>;\nexport type BaseRecipeLazyQueryHookResult = ReturnType<typeof useBaseRecipeLazyQuery>;\nexport type BaseRecipeQueryResult = Apollo.QueryResult<BaseRecipeQuery, BaseRecipeQueryVariables>;\nexport const MeDocument = gql`\n    query Me {\n  me {\n    ...RegularUser\n  }\n}\n    ${RegularUserFragmentDoc}`;\n\n/**\n * __useMeQuery__\n *\n * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.\n * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useMeQuery({\n *   variables: {\n *   },\n * });\n */\nexport function useMeQuery(baseOptions?: Apollo.QueryHookOptions<MeQuery, MeQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<MeQuery, MeQueryVariables>(MeDocument, options);\n      }\nexport function useMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MeQuery, MeQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<MeQuery, MeQueryVariables>(MeDocument, options);\n        }\nexport type MeQueryHookResult = ReturnType<typeof useMeQuery>;\nexport type MeLazyQueryHookResult = ReturnType<typeof useMeLazyQuery>;\nexport type MeQueryResult = Apollo.QueryResult<MeQuery, MeQueryVariables>;\nexport const RecipeIngredientsDocument = gql`\n    query RecipeIngredients($id: Int!, $original: Boolean!) {\n  recipeIngredients(recipeId: $id, original: $original) {\n    id\n    name\n    quantity\n  }\n}\n    `;\n\n/**\n * __useRecipeIngredientsQuery__\n *\n * To run a query within a React component, call `useRecipeIngredientsQuery` and pass it any options that fit your needs.\n * When your component renders, `useRecipeIngredientsQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useRecipeIngredientsQuery({\n *   variables: {\n *      id: // value for 'id'\n *      original: // value for 'original'\n *   },\n * });\n */\nexport function useRecipeIngredientsQuery(baseOptions: Apollo.QueryHookOptions<RecipeIngredientsQuery, RecipeIngredientsQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<RecipeIngredientsQuery, RecipeIngredientsQueryVariables>(RecipeIngredientsDocument, options);\n      }\nexport function useRecipeIngredientsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RecipeIngredientsQuery, RecipeIngredientsQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<RecipeIngredientsQuery, RecipeIngredientsQueryVariables>(RecipeIngredientsDocument, options);\n        }\nexport type RecipeIngredientsQueryHookResult = ReturnType<typeof useRecipeIngredientsQuery>;\nexport type RecipeIngredientsLazyQueryHookResult = ReturnType<typeof useRecipeIngredientsLazyQuery>;\nexport type RecipeIngredientsQueryResult = Apollo.QueryResult<RecipeIngredientsQuery, RecipeIngredientsQueryVariables>;\nexport const RecipeInstructionsDocument = gql`\n    query RecipeInstructions($id: Int!, $original: Boolean!) {\n  recipeInstructions(recipeId: $id, original: $original) {\n    id\n    position\n    description\n  }\n}\n    `;\n\n/**\n * __useRecipeInstructionsQuery__\n *\n * To run a query within a React component, call `useRecipeInstructionsQuery` and pass it any options that fit your needs.\n * When your component renders, `useRecipeInstructionsQuery` returns an object from Apollo Client that contains loading, error, and data properties\n * you can use to render your UI.\n *\n * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;\n *\n * @example\n * const { data, loading, error } = useRecipeInstructionsQuery({\n *   variables: {\n *      id: // value for 'id'\n *      original: // value for 'original'\n *   },\n * });\n */\nexport function useRecipeInstructionsQuery(baseOptions: Apollo.QueryHookOptions<RecipeInstructionsQuery, RecipeInstructionsQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<RecipeInstructionsQuery, RecipeInstructionsQueryVariables>(RecipeInstructionsDocument, options);\n      }\nexport function useRecipeInstructionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RecipeInstructionsQuery, RecipeInstructionsQueryVariables>) {\n          const options = {...defaultOptions, ...baseOptions}\n          return Apollo.useLazyQuery<RecipeInstructionsQuery, RecipeInstructionsQueryVariables>(RecipeInstructionsDocument, options);\n        }\nexport type RecipeInstructionsQueryHookResult = ReturnType<typeof useRecipeInstructionsQuery>;\nexport type RecipeInstructionsLazyQueryHookResult = ReturnType<typeof useRecipeInstructionsLazyQuery>;\nexport type RecipeInstructionsQueryResult = Apollo.QueryResult<RecipeInstructionsQuery, RecipeInstructionsQueryVariables>;"]},"metadata":{},"sourceType":"module"}